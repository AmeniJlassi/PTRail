# -*- coding: utf-8 -*-
"""geolife.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12Et3FeLSGgyy4B2gzkFeozobtV5QoOam
"""

!pip install ptrail

import pandas as pd
from ptrail.core.TrajectoryDF import PTRAILDataFrame
pd.set_option('max_columns', 100)

df = pd.read_csv('https://raw.githubusercontent.com/YakshHaranwala/PTRAIL/main/examples/data/geolife_sample.csv')
geo_df = PTRAILDataFrame(data_set=df,
                            latitude='lat',
                            longitude='lon',
                            datetime='datetime',
                            traj_id='id',
                            rest_of_columns=[])
print(f"The dimensions of the dataframe:{geo_df.shape}")
print(f"Type of the dataframe: {type(geo_df)}")

# Now, print the head of the seagulls_df dataframe.
geo_df.head()

"""
    To demonstrate the temporal features, we will:
        1. First, import the temporal_features.py module from the
           features package.
        2. Generate Date, Day_Of_Week, Time_Of_day features on
           the traffic dataset.
        3. Print the execution time of the code.
        4. Finally, check the head of the dataframe to
           see the results of feature generation.
"""
from ptrail.features.temporal_features import TemporalFeatures as temporal

temporal_features_df = temporal.create_date_column(geo_df)
temporal_features_df = temporal.create_day_of_week_column(temporal_features_df)
temporal_features_df = temporal.create_time_of_day_column(temporal_features_df)
temporal_features_df.head()

"""
    To demonstrate the kinematic features, we will:
        1. First, import the kinematic_features.py module from the
           features package.
        2. Calculate Distance, Jerk and Rate of bearing rate features on
           the traffic dataset.
        3. Print the execution time of the code.
        4. Finally, check the head of the dataframe to
           see the results of feature generation.
"""

from ptrail.features.kinematic_features import KinematicFeatures as kinematic

kinematic_features_df = kinematic.create_distance_column(geo_df)
"Jerk is the rate of change of acceleration with time"
kinematic_features_df = kinematic.create_jerk_column(kinematic_features_df)
"the measure of how quickly the compass bearing to an object changes over time"
kinematic_features_df = kinematic.create_rate_of_br_column(kinematic_features_df)
kinematic_features_df.head()

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# """
#     outliners and filters:
#         1. First, import the filters.py module from the
#            preprocessing package.
#         2. Detect outliers and Filter out data based on 
#             bounding box, date and distance.
#         3. Print the execution time of the code.
# """
# from ptrail.preprocessing.filters import Filters as filt
# 
# # Makes use of hampel filter from preprocessing package for outlier removal
# outlier_df = filt.hampel_outlier_detection(geo_df, column_name='lat')
# print(f"Length of original: {len(geo_df)}")
# print(f"Length after outlier removal: {len(outlier_df)}")
# print(f"Number of points removed: {len(geo_df) - len(outlier_df)}")

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# # Filters and gives out data contained within the given bounding box
# 
# #Now, let create a bounding box of 100 km radius from the
# #coordinates 39, 116.
# filter_df_bbox = filt.get_bounding_box_by_radius(39, 116, 100000)
# print(f"Length of original: {len(geo_df)}")
# print(f"Length of data in the bounding box: {len(filter_df_bbox)}")
# print(f"Number of points removed: {len(geo_df) - len(filter_df_bbox)}")

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# # Gives out the points contained within the given date range
# filter_df_date = filt.filter_by_date(temporal_features_df, 
#                                      start_date='2008-10-23 05:53:11', 
#                                      end_date='2008-11-01 15:25:14')
# print(f"Length of original: {len(temporal_features_df)}")
# print(f"Length of data within specified date: {len(filter_df_date)}")
# print(f"Number of points removed: {len(temporal_features_df) - len(filter_df_date)}")

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# # Filtered dataset with a given maximum distance 
# filter_df_distance = filt.filter_by_max_consecutive_distance(kinematic_features_df, max_distance=4600)
# print(f"Length of original: {len(kinematic_features_df)}")
# print(f"Length of Max distance Filtered DF: {len(filter_df_distance)}")
# print(f"Number of points removed: {len(kinematic_features_df) - len(filter_df_distance)}")

"""
    INTERPOLATION
    First, the following operations are performed:
        1. Import the necessary interpolation modules
           from the preprocessing package.
        2. Select a single trajectory ID from the seagulls
           dataset and then plot it using folium.
        3. The number of points having time jump greater than
           4 hours between 2 points is also calculated and shown.
"""
import ptrail.utilities.constants as const
import folium
from ptrail.preprocessing.interpolation import Interpolation as ip

small_geo = geo_df.reset_index().loc[geo_df.reset_index()[const.TRAJECTORY_ID] == '1'][[const.TRAJECTORY_ID, const.DateTime, const.LAT, const.LONG]]
time_del = small_geo.reset_index()[const.DateTime].diff().dt.total_seconds()
print((time_del > 3600*4).value_counts())

# Here, we plot the smaller trajectory on a folium map.
sw = small_geo[['lat', 'lon']].min().values.tolist()
ne = small_geo[['lat', 'lon']].max().values.tolist()
coords = [zip(small_geo[const.LAT], small_geo[const.LONG])]
m1 = folium.Map(location=[small_geo[const.LAT].iloc[0], small_geo[const.LONG].iloc[0]], zoom_start=1000)

folium.PolyLine(coords,
                color='green',
                weight=2,
                opacity=0.7).add_to(m1)
m1.fit_bounds([sw, ne])
m1

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# """
#     Now, to demonstrate interpolation, the following steps
#     are taken:
#         1. Interpolate the selected trajectory using all of
#            the above mentioned techniques and print their
#            execution times along with them.
#         2. Then, plot all the trajectories side by side along
#            with the original trajectory on a scatter plot to
#            see how the time jumps are filled and the points
#            are inserted into the trajectory.
# """
# 
# # First, linear interpolation is performed.
# linear_ip_geo = ip.interpolate_position(dataframe=small_geo,
#                                           time_jump=3600*4,
#                                           ip_type='linear')
# print(f"Original DF Length: {len(small_geo)}")
# print(f"Interpolated DF Length: {len(linear_ip_geo)}")

# Commented out IPython magic to ensure Python compatibility.
# %%time
# # Now, cubic interpolation is performed.
# cubic_ip_geo = ip.interpolate_position(dataframe=small_geo,
#                                          time_jump=3600*4,
#                                          ip_type='cubic')
# print(f"Original DF Length: {len(small_geo)}")
# print(f"Interpolated DF Length: {len(cubic_ip_geo)}")

# Commented out IPython magic to ensure Python compatibility.
# %%time
# # Now, random-walk interpolation is performed.
# rw_ip_geo = ip.interpolate_position(dataframe=small_geo,
#                                       time_jump=3600*4,
#                                       ip_type='random-walk')
# print(f"Original DF Length: {len(small_geo)}")
# print(f"Interpolated DF Length: {len(rw_ip_geo)}")

# Commented out IPython magic to ensure Python compatibility.
# %%time
# # Now, kinematic interpolation is performed.
# kin_ip_geo = ip.interpolate_position(dataframe=small_geo,
#                                        time_jump=3600*4,
#                                        ip_type='kinematic')
# print(f"Original DF Length: {len(small_geo)}")
# print(f"Interpolated DF Length: {len(kin_ip_geo)}")

"""
    Now, plotting all the scatter plots side by side
    in order to compare the interpolation techniques.
"""
import matplotlib.pyplot as plt


plt.scatter(small_geo[const.LAT],
            small_geo[const.LONG],
            s=15, color='purple')
plt.title('Original Trajectory', color='black', size=15)
plt.show()

print()

fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(25, 20))

ax[0, 0].scatter(linear_ip_geo[const.LAT],
                 linear_ip_geo[const.LONG],
                 s=50, color='red')
ax[0, 0].set_title('Linear Interpolation', color='black', size=40)
ax[0, 1].scatter(cubic_ip_geo[const.LAT],
                 cubic_ip_geo[const.LONG],
                 s=50, color='orange')
ax[0, 1].set_title('Cubic Interpolation', color='black', size=40)
ax[1, 0].scatter(rw_ip_geo[const.LAT],
                 rw_ip_geo[const.LONG],
                 s=50, color='blue')
ax[1, 0].set_title('Random-Walk Interpolation', color='black', size=40)
ax[1, 1].scatter(kin_ip_geo[const.LAT],
                 kin_ip_geo[const.LONG],
                 s=50, color='brown')
ax[1, 1].set_title('Kinematic Interpolation', color='black', size=40)

for plot in enumerate(ax.flat):
    plot[1].set_xlabel('Latitude', color='grey', size=25)
    plot[1].set_ylabel('Longitude', color='grey', size=25)